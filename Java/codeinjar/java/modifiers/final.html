<!DOCTYPE html>
<html>

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Final class members in Java</title>
  
  <style>
  
  *{
    box-sizing: border-box;
  }
  html, body{
    margin-left: 8px;
    margin-right: 8px;
    padding: 0px;
  }
  pre code {
    background-color: #eee;
    border: 1px solid #999;
    display: block;
    padding: 8px;
    overflow: auto;
    border-left: 3px solid red;
}
  .left-border{
    border-left: 3px solid red;
  }  

  .highlight-text{
    background-color: papayawhip;
    color: black;
    display: inline;
    }
  .highlight-section{
    box-sizing: border-box;
    background-color: papayawhip;
    border-left: 5px solid red;
    color: black;
    padding: 3px 8px 3px 8px;
    }
    
</style>

</head>

<body>
  
  <div>
  <h1>Final class members in Java</h1>
  <p>
    When a class members are final either attributes or methods, they can't be reinitialized/overriden.
</p>

<p>
Let's check out through few examples.
</p>

<p>
<b>Example 1: (inside main method)</b>
</p>

<p>
<pre><code>
class A{
  
  public static void main (String[] args){
    //final members
    final int number = 10; //instantiate+initialize
    
    //access the private number variable
    System.out.println("Number is: "+number);
    
  }
}

/**
 * Output: 
 * Number is: 10
 */
</code></pre>
</p>

<p>
But what if you try to reinitialize the number variable?
</p>

<p>
<pre><code>
class A{
  
  public static void main (String[] args){
    //final members
    final int number = 10; //instantiate+initialize
    
    // try to update the final variable
    number = 100;
    //access the private number variable
    System.out.println("Number is: "+number);
    
  }
}

/**
 * Output: 
 * <error message> such as
 * can not reassign a value to final
 * variable number 
 */
</code></pre>
</p>

<p>
<b>Example 2: (final class members)</b>
</p>

<p>
Yes, class members can also be final but it provides few restrictions over them. Like, you can't change the variable value once you initialized. 
</p>

<p>
When, attributes are final: It is not possible to reinitialize the variable value once initialized.
</p>

<p>
<b>Like:</b> 
</br>
<pre><code>
final int x = 10; //instantiation + initialization
x = 100; //try to change the value, but it's not. possible


//Or, 

final int x; //just declaring the final variable

x = 10; //initialize the first time
x = 100; 
//now it's produce compile time error as it's not possible reinitialize the final variable onece initialized.

</code></pre>
</p>
Look over the following simple example now: 

<p>
<pre><code>
class Main{
  //final member 
  static final int number = 10;
  
  public static void main (String[] args) {
    //access the final static variable
    System.out.println("Number is " +number);
  }
}

/**
 * Output:.
 * Number is 10
 */
</code></pre>
</p>

<p>
Let's try to change the number variable after initializing. (inside the main method)
</p>

<p>
<pre><code>
class Main{
  //final member 
  static final int number = 10;
  
  public static void main (String[] args) {
    //access the final static variable
    //try to reinitialize the variable
    
    number = 100;
    System.out.println("Number is " +number);
  }
}

/**
 * Output:.
 * <error_message> such as
 * can not re assign a value to a finsl variable
 * number
 */
</code></pre>
</p>

<p>
Even, it is not possible to access the final variable without initializing. You must initialize the final variable before accessing it.
</p>

<p>
<b>Like:</b>
</p>

<p>
<pre><code>
class Main{

  public static void main (String[] args) {
    //access the final static variable
    //try to reinitialize the variable
    
    final int number= 100;
    System.out.println("Number is " +number);
  }
}

/**
 * Output:.
 * <error_message> such as
 * variable number might not have been
*  initialized
 * 
 */
</code></pre>
</p>

<p>
<b>Example 3: (methods are final)</b>
</p>

<p>
When methods are final in a class, you can't override it. Means, modification of the method is not possible.
</p>

<p>
<b>Like:</b>
</p>

<p>
<pre><code>
class A {
    public static void hello(){
        System.out.println("Hello Java!");
    }
}
class HelloWorld extends A{
    
    public static void hello(){
        System.out.println("Hello, Jenkov!");
    }
    public static void main(String[] args) {
        //invoke the method hello()
        hello();
    }
}
</code></pre>
</p>

<p>
If you run the above example, what you aspect as output?
</p>

<p>
Output is: </br>
Hello, Jenkov! </br>
</br>
instead of Hello, Java! Because we have overriden the method and it's body in the subclass. 
</p>

<p>
But what if the method is final?
</br>

Then, you get compile time error like this: </br>
Overriden method is final.
</p>

<p>
<pre><code>
class A {
    public static final void hello(){
        System.out.println("Hello Java!");
    }
}
class HelloWorld extends A{
    
    public static final void hello(){
        System.out.println("Hello, Jenkov!");
    }
    public static final void main(String[] args) {
        //invoke the method hello()
        hello();
    }
}
</code></pre>
</p>

<p>
Run the above example now, and you see a simple error message in the console.
</p>
<p class="highlight-section">
/**
 * <error_message>
 * Overriden method hello() is final
 * 
 * /
</p>

<p>
Note: Every method in java must have method body or return type. Unless it is abstract method. Really?
</p>

<p>
Otherwise, you will get error like this: Method body is missing. 
</p>
  </div>
  
</body>

</html>